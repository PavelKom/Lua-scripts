--[[
	Chemlib Autocraft by PavelKom v0.3

	Autocrafting chemical elements from the chemlib mod using reactors from Alchemistry and ME-RS Bridges
	Config elements.json is based on
	https://github.com/SmashingMods/ChemLib/blob/9d42c5b4ec148a1497a04c79eee32b5216a2d30e/src/main/resources/data/chemlib/elements.json
	
	Main element used: Carbon (from Coal, Charcoal or Diamonds)
	The main element is obtained from the Dissolver
	Elements with atomic numbers 1-7 are obtained from the Fission Reactor
		Start crafting only if amount of required element >= 1000
		required  products
		V		  V
		Si(14) -> 2N(7)
	The remaining elements are obtained from the Fusion Reactor
		Start crafting only if amount of required element >= 1000
										 main element >= 1000
		required main element
		V		 V
		Ti(22) + C(6) -> Ni(28)
						 ^
						 product
	
	chemlib_import.lua - Lua script for reconfigurate elements.json (ingame)
	chemlib_import.py - Python script for reconfigurate elements.json
]]
-- Path for searching packages
if not string.find(package.path, "./src/?.lua", 1, true) then
	package.path = package.path..';./src/?.lua'
end
if not string.find(package.path, "./lib/?.lua", 1, true) then
	package.path = package.path..';./lib/?.lua'
end
if not string.find(package.path, "./include/?.lua", 1, true) then
	package.path = package.path..';./include/?.lua'
end
--------------------------------- LOAD LIBRARIES --------------------------------
local Monitor = require "monitor_util"
local MEBridge = require "me_util"
local RSBridge = require "rs_util"
local expect = require "cc.expect"
local events = require "event_util"
local expect, field = expect.expect, expect.field
local Trigger = RSBridge.Trigger
local CraftTask = RSBridge.CraftTask
local SIDES = RSBridge.SIDES
---------------------------------- CONFIG PART ----------------------------------
local bridges = 3 -- 1 - only ME, 2 - only RS, 3 - both
local main_storage = "me"
local main_element = 6 -- Atomic number of main element
local JSON_PATH = "elements.json" -- JSON-config generated by chemlib_import.lua or chemlib_import.py
local me_bridge_name = "" -- Set a name if you use more than ONE MEBridge
local rs_bridge_name = ""
local monitor_name = ""
local REQUIRED_AMOUNT = 1000 -- Task target amount
local CRAFT_BATCH = 1 -- Craft batch
---------------------------------------------------------------------------------

--DO NOT CHANGE ANYTHING BELOW THIS LINE UNLESS YOU ARE SURE WHAT YOU ARE DOING--

local BRIDGE = {ME=MEBridge(me_bridge_name), RS=RSBridge(rs_bridge_name)}
local MONITOR = Monitor(monitor_name)

if not MONITOR then
	error("Can't connect to Monitor("..monitor_name..")")
elseif not BRIDGE.ME and bridges % 2 == 1 then
	error("Can't connect to MEBridge("..me_bridge_name..")")
elseif not BRIDGE.RS and bridges // 2 == 1 then
	error("Can't connect to RSBridge("..rs_bridge_name..")")
end

local _AUTONAME = 0
local function autoname()
	_AUTONAME = _AUTONAME + 1
	return "_"..tostring(_AUTONAME)
end

local Element = {ME={},RS={}}
Element.__name = {}
function Element:new(data)
	field(data, "x", "number")
	field(data, "y", "number")
	local self = {}
	self.label = data.abbreviation
	self.name = data.name
	self.index = data.atomic_number
	self.bridge = string.upper(data.bridge or "rs")
	self.x = data.x
	self.y = data.y
	self.required = data.required or {}
	self.color = data.color or colors.red
	self.amount = data.amount or REQUIRED_AMOUNT
	
	self.draw = function(color)
		MONITOR.pos(self.x, self.y)
		MONITOR.bg = color or self.color
		MONITOR.write(self.label)
	end
	if self.name then
		local t1 = Trigger({name=self.name},_,_,_,_,_,self.amount * (10 and main_element == self.index or 1))
		local t2
		for _, v in pairs(self.required) do
			t2 = Trigger({name=v[2]},_,_,
			Trigger.OP.GE,
			_,_,self.amount * (1 and main_element == v[1] or 0.5),
			_, t2)
		end
		t1.trigger = t2
		self.task = CraftTask({name=self.name}, _, self.amount, CRAFT_BATCH, t1)
		self.done = Trigger({name=self.name},_,_,_,_,_, self.amount * (10 and main_element == self.index or 1))
		self.excess = Trigger({name=self.name},_,_,_,_,_, self.amount * (20 and main_element == self.index or 2))
	else
		self.name = autoname()
	end
	
	self.draw()
	Element[self.bridge or "_"][#Element[self.bridge or "_"]+1] = self
	Element.__name[name] = self
	return self
end

local ELEMENT_JSON = {}

-- Generate tasks for crafting
local function updateElements()
	local f = io.open(JSON_PATH, "r")
	ELEMENT_JSON = textutils.unserializeJSON(f:read('*a'))
	f:close()
	-- Remove old element data
	for k, _ in pairs(Element.__name) do
		table.remove(Element.__name, k)
	end
	while BRIDGE.ME and #Element.ME > 0 then
		table.remove(Element.ME)
	end
	while BRIDGE.RS and #Element.RS > 0 then
		table.remove(Element.RS)
	end
	-- Remove olda tasks
	if BRIDGE.ME then BRIDGE.ME.clearTasks() end
	if BRIDGE.RS then BRIDGE.RS.clearTasks() end
	-- Register elements
	for _, element in pairs(ELEMENT_JSON) do
		Element(element)
	end
end

local color_table = {
	[1] = colors.yellow,
	[0] = colors.red,
	[-1] = colors.pink,
	[-2] = colors.orange,
	[-3] = colors.purple,
	[-4] = colors.cyan,
	[-5] = colors.green
}
setmetatable(color_table, {__index = color_table[1]})
local QUEUE = {ME={}, RS={}}
local CO = {}

-- CraftTask callback
local function craftCallback(result, item, bridge)
	local name = item.name
	local e = Element.__name[name]
	e.draw(color_table[result])
	sleep(1)
	CO[e.bridge]()
end

-- Coroutine method
local function loopCraft(bridge)
	if BRIDGE[bridge] == nil then return end
	while true do
		while #QUEUE[bridge] > 0 do
			local e = QUEUE[bridge][#QUEUE[bridge]]
			table.remove(QUEUE[bridge])
			coroutine.resume(
				coroutine.create(
					function()
						e.task.craft(BRIDGE[bridge], craftCallback)
					end
				)
			)
			coroutine.yeild()
		end
		sleep(10)
		for _, v in pairs(Element[bridge]) do
			local e = Element.__name[v]
			if e.excess.test() then
				e.draw(colors.lime)
			elseif e.done.test() then
				e.draw(colors.green)
			else
				QUEUE[bridge][#QUEUE[bridge]+1] = e
			end
		end
		sleep(10)
	end
end
CO.ME = coroutine.wrap(function() loopCraft('ME') end)
CO.RS = coroutine.wrap(function() loopCraft('RS') end)

updateElements()
CO.ME()
CO.RS()
